<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="To Dos">
    <link rel="manifest" href="/manifest.json"> <link href="https://fonts.googleapis.com/css2?family=Gloria+Hallelujah&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" href="/icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Gloria+Hallelujah&display=swap" rel="stylesheet">
    <title>To Do</title>
    <!-- Lade Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #233d4d !important;
        }

        .font-gloria {
            font-family: 'Gloria Hallelujah';
        }


        .orange-semi-circle {
            background: linear-gradient(
                to bottom,        /* Startet oben und verl√§uft nach unten */
                #ff9d47,          /* Helleres Orange (oben) */
                #fe7f2d,     /* Dein Original-Orange (#fe7f2d) startet bei 60% */
                #99440b           /* Dunkleres Orange (unten) */
            );
            
            /* NEU: Gr√∂√üere H√∂he und relative Breite, um mehr Pr√§senz zu haben */
            height: 100vh;  /* Fast die gesamte Viewport-H√∂he */
            width: 20vw;  /* Die Breite basiert nur auf 30% der Viewport-Breite */
            
            /* Radius muss gleich der Breite sein (30vw) */
            border-top-left-radius: 30vw;
            border-bottom-left-radius: 30vw; 
            
            /* Positionierung */
            position: fixed; 
            right: 0;
            top: 50%; /* Vertikal zentrieren */
            transform: translateY(-50%); 
            z-index: 0; /* Im Hintergrund */
            opacity: 0.80; 
        }

        .no-scroll {
            overflow: hidden; /* Verhindert das Scrollen von Inhalten, die √ºber den Viewport hinausragen */
            touch-action: none; /* WICHTIG: Deaktiviert alle standardm√§√üigen Touch-Gesten (wie vertikales Scrollen) */
        }

        .modal-sheet * {
            /* Deaktiviert die Markierung von Text innerhalb des Modal sheets */
            -webkit-user-select: none;  /* F√ºr Safari/Chrome */
            -moz-user-select: none;     /* F√ºr Firefox */
            -ms-user-select: none;      /* F√ºr IE/Edge */
            user-select: none;
        }

    </style>
</head>
<body class="bg-[#233d4d] text-white min-h-screen flex flex-col items-center p-4">
    <!-- 1. Der Orange Halbkreis (Hintergrund) - Jetzt auf allen Ger√§ten sichtbar -->
    <div class="orange-semi-circle"></div>

    <!-- 2. Haupt-Inhalts-Wrapper (Muss √ºber dem Halbkreis liegen: z-10) -->
    <div class="main-content-wrapper w-full max-w-lg z-10 flex flex-col items-center">
        <header class="text-center mb-8 w-full">
            <!-- Textfarbe auf Wei√ü gesetzt f√ºr optimalen Kontrast auf Orange -->
            <h1 class="font-gloria text-5xl font-extrabold text-[#fe7f2d] mb-2">
                üöÄ Meine To Dos
            </h1>
        </header>

    <div id="todo-list" class="w-full max-w-lg space-y-4 z-10"></div>

     <!-- FLOATING ACTION BUTTON (FAB) -->
    <button id="fab-button" 
            class="fixed bottom-6 
                   right-1/2 transform translate-x-1/2 
                   w-14 h-14 
                   rounded-full 
                   bg-[#fe7f2d] text-[#233d4d]
                   shadow-xl 
                   flex items-center justify-center text-3xl font-bold 
                   transition-all duration-300 
                   hover:scale-110 active:scale-95 
                   z-50">
        <!-- Lucide Plus Icon, h√§ufig in FABs verwendet -->
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M5 12h14"/><path d="M12 5v14"/>
        </svg>
    </button>
    <!-- ENDE FAB -->

    <!-- üî• NEUES BOTTOM SHEET -->
    <div id="bottom-sheet" 
        class="fixed inset-0 z-[100] hidden">

        <!-- Sheet-Container -->
        <div id="bottom-sheet-container"
            class="absolute bottom-0 left-0 right-0 
                    bg-[#fe7f2d]/30       /* Orange, 30% Opacity */
                    backdrop-blur-xl       /* Starker Blur f√ºr Glassmorphism */
                    rounded-t-3xl shadow-2xl
                    p-6 
                    transform translate-y-full 
                    transition-transform duration-300">
            <!-- Close Button oben rechts -->
            <button id="close-bottom-sheet-button"
                    class="absolute top-4 right-4 text-[#233d4d] hover:text-gray-800">
                <!-- kleines X-Icon im iOS/Material-Stil -->
                <svg xmlns="http://www.w3.org/2000/svg" 
                    width="24" height="24" viewBox="0 0 24 24" 
                    fill="none" stroke="currentColor" 
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>


             <!-- Modal Header -->
            <h3 class="text-3xl font-bold text-[#fe7f2d] mb-4">
                <span class="font-gloria text-3xl mr-3">üìù Neues To Do</span>   
            </h3>
            <!-- Textarea -->
            <textarea id="unified-todo-input"
                    class="w-full h-12 p-3 rounded-xl bg-white/10 backdrop-blur-sm text-[#233d4d] resize-none 
                            placeholder-[#fe7f2d] font-gloria focus:outline-none focus:ring-2 focus:ring-orange-700 transition duration-150 shadow-inner mb-4"
                    placeholder="..."></textarea>


            <!-- Button-Leiste: Record & Photo & Save -->
            <div class="flex justify-center space-x-16 pt-2">
                <!-- Mikrofon (Press-and-Hold) -->
                <button id="record-button"
                        class="w-14 h-14 rounded-full bg-[#233d4d] hover:bg-[#3b5971] text-[#fe7f2d] shadow-xl transition duration-150 disabled:opacity-50 flex items-center justify-center text-2xl active:recording-pulse"
                        title="Halten Sie die Maustaste gedr√ºckt, um aufzunehmen">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 z-10">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" x2="12" y1="19" y2="22"/>
                    </svg>
                </button>

                <button id="photo-button"
                        class="w-14 h-14 rounded-full bg-[#233d4d] hover:bg-[#3b5971] text-[#fe7f2d] shadow-xl transition duration-150 flex items-center justify-center text-2xl"
                        title="Bilder hinzuf√ºgen">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                        <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
                        <circle cx="12" cy="13" r="3"/>
                    </svg>
                </button>

                <!-- Add / Save Button (Primary Action - Plus Icon) -->
                <button id="save-unified-button"
                        class="w-14 h-14 rounded-full bg-[#233d4d] hover:bg-[#3b5971] text-[#fe7f2d] shadow-xl transition duration-150 disabled:opacity-50 flex items-center justify-center text-3xl font-bold"
                        title="Aufgabe speichern">
                    +
                </button>
            </div>

        </div>
    </div>

    <script>
        // *** Frontend-Logik: Aufnahme, Base64-Kodierung & Senden an Python-Backend ***
        
        // Konstanten f√ºr UI-Elemente
        const API_BASE_URL = "https://indextest-ogpo.onrender.com";
        const statusText = document.getElementById('status-text');
        const recordButton = document.getElementById('record-button');
        const resultText = document.getElementById('result-text');
        const base64Size = document.getElementById('base64-size');
        const statusContainer = document.getElementById('status-container');
        const fabButton = document.getElementById('fab-button'); 
        const bottomSheet = document.getElementById("bottom-sheet");
        const bottomSheetContainer = document.getElementById("bottom-sheet-container");
        const closeBottomSheetButton = document.getElementById("close-bottom-sheet-button");
        const input = document.getElementById("unified-todo-input");
        const saveButton = document.getElementById("save-unified-button");
        const todoList = document.getElementById("todo-list");

        let mediaRecorder;
        let audioChunks = [];
        let stream;
        let isRecording = false; 

        
        // Versucht zuerst MP4 (besser f√ºr iOS/Safari) und f√§llt auf WebM zur√ºck
        // WICHTIG: Die Wahl hier wird an das Backend gesendet, um das korrekte Google-Encoding zu setzen.
        const preferredMimeType = MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : 'audio/webm';


        function openBottomSheet() {
            bottomSheet.classList.remove("hidden");

            // erst runterholen
            bottomSheetContainer.classList.remove("translate-y-full");

            // Pop-Animation sauber resetten
            bottomSheetContainer.classList.remove("bottom-sheet-pop");
            void bottomSheetContainer.offsetWidth; 
            bottomSheetContainer.classList.add("bottom-sheet-pop");
        }

        fabButton.addEventListener("click", openBottomSheet);

        
        function closeBottomSheet() {
            bottomSheetContainer.classList.remove("bottom-sheet-pop");
            bottomSheetContainer.classList.add("translate-y-full");

            setTimeout(() => {
                bottomSheet.classList.add("hidden");
            }, 300);
        }


        closeBottomSheetButton.addEventListener("click", closeBottomSheet);


        saveButton.addEventListener("click", () => {
            const text = input.value.trim();
            if (!text) return;

            createTodoCard(text);
            input.value = ""; // leeren

            closeBottomSheet(); // ‚Üê das ist jetzt alles
        });

        function enableSwipe(card) {
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            const threshold = 150; // weiter ziehen, bevor gel√∂scht wird
            const maxShift = 300; ¬†// maximale Verschiebung f√ºr Farbprogression

            function start(positionX) {
                // üî• NEU: Scrollen sperren, sobald die Geste beginnt
                document.body.classList.add('no-scroll'); 
                
                startX = positionX;
                isDragging = true;
                card.style.transition = "none";
            }

            function move(positionX) {
                if (!isDragging) return;
                currentX = positionX - startX;
                card.style.transform = `translateX(${currentX}px)`;

                // --- Progressive Dark Red ---
                const intensity = Math.min(Math.abs(currentX) / maxShift, 1); // 0..1
                // WICHTIG: Die urspr√ºngliche Logik f√ºr den Hintergrund war unsauber.
                // Wir verwenden eine feste Farbe, die zur roten Farbe wird, wenn man swiped.
                const redValue = Math.floor(255 * intensity);
                const redHex = Math.min(255, Math.floor(255 * intensity));
                const originalColor = '#fe7f2d'; // Deine aktuelle Akzentfarbe
                const swipeColor = `rgb(${redHex}, 0, 0)`; 
                
                // Wir setzen die Hintergrundfarbe dynamisch.
                card.style.background = `linear-gradient(to right, ${swipeColor}, ${originalColor})`;
            }

            function end() {
                if (!isDragging) return;
                isDragging = false;
                
                // üî• NEU: Scrollen freigeben, wenn die Geste endet
                document.body.classList.remove('no-scroll');

                card.style.transition = "0.2s";

                if (Math.abs(currentX) > threshold) {
                    if (navigator.vibrate) navigator.vibrate(40);
                    card.style.opacity = "0";
                    card.style.transform = `translateX(${currentX > 0 ? 200 : -200}px)`;
                    
                    // L√∂schen: Timeout beibehalten
                    setTimeout(() => card.remove(), 200);
                } else {
                    // Zur√ºcksetzen:
                    card.style.transform = "translateX(0)";
                    // Zur√ºck zur urspr√ºnglichen Hintergrundfarbe
                    card.style.background = "linear-gradient(to right, rgba(35,61,77,0.1), rgba(254,127,45,0.8))";
                }
                
                // currentX zur√ºcksetzen, um Fehler bei neuen Gesten zu vermeiden
                currentX = 0; 
            }

            // --- Touch Events ---
            card.addEventListener("touchstart", (e) => start(e.touches[0].clientX));
            card.addEventListener("touchmove", (e) => move(e.touches[0].clientX));
            card.addEventListener("touchend", end);

            // --- Maus Events ---
            card.addEventListener("mousedown", (e) => start(e.clientX));
            window.addEventListener("mousemove", (e) => move(e.clientX));
            window.addEventListener("mouseup", end);
        }


        function createTodoCard(text) {
            const wrapper = document.createElement("div");
            wrapper.className = "swipe-wrapper relative";

            const card = document.createElement("div");
            card.className = `
                todo-card
                bg-gradient-to-r from-[#233d4d]/10 to-[#fe7f2d]/60
                backdrop-blur-xl
                text-[#fe7f2d]
                rounded-2xl p-4 shadow-lg
                transition-transform duration-300
                relative z-10
            `;

            card.innerHTML = `
                <div class="flex justify-between items-center">
                    <p class="text-2xl">${text}</p>
                    <span class="drag-handle text-[#233d4d] text-2xl opacity-90">‚ò∞</span>
                </div>
            `;

            // üî• ROTE L√ñSCHFL√ÑCHE
            const bg = document.createElement("div");
            bg.className = `
                delete-bg absolute inset-0 
                bg-red-600 rounded-2xl 
                opacity-0 transition-opacity duration-200
            `;

            wrapper.appendChild(bg);
            wrapper.appendChild(card);
            todoList.appendChild(wrapper);

            enableSwipe(card, bg, wrapper);
            enableReorder(wrapper);

        }

        function enableReorder(wrapper) {
            const card = wrapper.querySelector(".todo-card"); 
            const handle = card.querySelector(".drag-handle");
            const list = todoList; // Wir wissen, dass es immer todoList ist

            let isDragging = false;
            let startY = 0;
            let initialWrapperY = 0; 
            let initialScrollY = 0; // Speichert die Scrollposition zu Beginn

            function pointerDown(e) {
                // Ignoriere Klicks, die nicht die linke Maustaste sind (z.B. Rechtsklick)
                if (e.button === 2) return; 

                e.stopPropagation(); 
                e.preventDefault();

                document.body.classList.add('no-scroll');
                
                isDragging = true;
                startY = e.clientY || e.touches?.[0]?.clientY;
                initialScrollY = window.scrollY; // Scrollposition erfassen

                // üî• L√ñSUNG F√úR PROBLEM 2 (Breite und Position fixieren)
                const rect = wrapper.getBoundingClientRect();
                
                wrapper.style.position = 'absolute'; 
                wrapper.style.width = `${rect.width}px`; // <--- Breite fixieren
                wrapper.style.left = `${rect.left}px`; ¬† // <--- Linke Position fixieren
                
                // Y-Position relativ zum Dokument setzen:
                initialWrapperY = rect.top + window.scrollY;
                wrapper.style.top = `${initialWrapperY}px`; 

                wrapper.style.zIndex = '1000';
                card.style.transition = "none";
                card.classList.add("opacity-50", "scale-95", "shadow-2xl");

                document.addEventListener("pointermove", pointerMove);
                document.addEventListener("pointerup", pointerUp);
            }

            function pointerMove(e) {
                if (!isDragging) return;

                const y = e.clientY || e.touches?.[0]?.clientY;
                const delta = y - startY;

                // Verschiebe den Wrapper mit Ber√ºcksichtigung der anf√§nglichen Scroll-Position
                wrapper.style.top = `${initialWrapperY + delta}px`;

                const cards = [...list.children];
                const currentCardRect = wrapper.getBoundingClientRect();
                const currentMiddle = currentCardRect.top + currentCardRect.height / 2;

                cards.forEach(otherWrapper => {
                    if (otherWrapper === wrapper) return;

                    const rect = otherWrapper.getBoundingClientRect();
                    const middle = rect.top + rect.height / 2;

                    if (currentMiddle > middle && currentMiddle > rect.top) {
                        // Verschiebe nach unten
                        list.insertBefore(wrapper, otherWrapper.nextSibling);
                    } else if (currentMiddle < middle && currentMiddle < rect.bottom) {
                        // Verschiebe nach oben
                        list.insertBefore(wrapper, otherWrapper);
                    }
                });
            }

            function pointerUp() {
                if (!isDragging) return;

                isDragging = false;

                document.body.classList.remove('no-scroll');

                // üî• L√ñSUNG F√úR PROBLEM 1 & 2 (Reset der Positionierung)
                card.style.transition = "0.2s";
                
                // Entfernt alle Inline-Styles, um auf die urspr√ºnglichen CSS-Klassen zur√ºckzufallen
                wrapper.style.removeProperty('position');
                wrapper.style.removeProperty('top');
                wrapper.style.removeProperty('left');
                wrapper.style.removeProperty('width');
                wrapper.style.removeProperty('z-index'); 
                
                card.classList.remove("opacity-50", "scale-95", "shadow-2xl");

                document.removeEventListener("pointermove", pointerMove);
                document.removeEventListener("pointerup", pointerUp);
            }

            handle.addEventListener("pointerdown", pointerDown);
        }

        async function transcribeAudio(base64Audio, mimeType) {
            input.value = "Verarbeitung l√§uft...üòÑ";

            try {
                const response = await fetch(API_BASE_URL + '/transcribe', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ audio_base64: base64Audio, mime_type: mimeType })
                });

                const data = await response.json();

                if (response.ok) {
                    const transcript = data.transcript;
                    
                    // üî• KORRIGIERT: Ergebnis in die Textarea schreiben
                    input.value = transcript; 
                    input.focus(); 
                    // ‚ùå Vorher: updateStatus("Transkription abgeschlossen!", ...);
                    
                } else {
                    const errorMessage = data.error || "Unbekannter Fehler im Python-Backend.";
                    // Gib den Fehler im Eingabefeld aus
                    input.value = `[FEHLER] ${errorMessage}`; 
                    // ‚ùå Vorher: updateStatus("API-Fehler", ...);
                }
                
            } catch (error) {
                // Netzwerkfehler
                input.value = `[NETZWERKFEHLER] Konnte Backend nicht erreichen. (${error.message})`;
                // ‚ùå Vorher: updateStatus("Netzwerkfehler", ...);
            }
        }

        function startRecording(e) {
            // 1. Pr√ºfe, ob wir schon aufnehmen oder ob es nicht der Record Button ist.
            if (isRecording) return;
            
            // 2. Wichtig: Verhindert, dass der Browser ein unn√∂tiges Click-Event ausl√∂st,
            //    aber wir m√ºssen den Pointer Capture setzen.
            e.preventDefault(); 
            
            // 3. Wenn es ein Pointer-Event ist, Capture setzen.
            if (e.pointerId !== undefined) {
                // Stellt sicher, dass das pointerup-Event auch au√üerhalb des Buttons gefeuert wird.
                e.target.setPointerCapture(e.pointerId); 
            }
            
            if (!stream) {
                input.value = "[FEHLER] Mikrofon nicht bereit. Erlaubnis verweigert?";
                return;
            }
            
            isRecording = true;
            recordButton.classList.add('recording-pulse');
            input.value = "üî• Aufnahme l√§uft... ";

            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: preferredMimeType });
            } catch (error) {
                input.value = `[FEHLER] MediaRecorder konnte nicht initialisiert werden: ${error.message}`;
                isRecording = false;
                recordButton.classList.remove('recording-pulse');
                return;
            }

            audioChunks = [];
            
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                if (audioChunks.length === 0) {
                    input.value = "[HINWEIS] Aufnahme zu kurz oder keine Daten erfasst.";
                    return;
                }

                const mimeType = mediaRecorder.mimeType;
                const audioBlob = new Blob(audioChunks, { type: mimeType });
                const reader = new FileReader();
                
                reader.onloadend = () => {
                    const base64Audio = reader.result.split(',')[1];
                    transcribeAudio(base64Audio, mimeType);
                };
                reader.readAsDataURL(audioBlob);
            };

            mediaRecorder.start();
            console.log("Aufnahme gestartet...");
        }

        function stopRecording(e) {
            if (!isRecording) return;
            
            isRecording = false; 
            recordButton.classList.remove('recording-pulse');

            // Wenn Pointer Capture gesetzt wurde, muss es freigegeben werden.
            if (e.pointerId !== undefined) {
                e.target.releasePointerCapture(e.pointerId);
            }
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                console.log("Aufnahme gestoppt. Starte Transkription...");
            }
        }

        // --- INITIALISIERUNG ---

        async function initRecorder() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log(`Mikrofon bereit. Format: ${preferredMimeType}`);
                recordButton.disabled = false;
                
                // üî• WICHTIG: pointerdown/pointerup verwenden, aber nur auf dem Button lauschen
                recordButton.addEventListener('pointerdown', startRecording); 
                recordButton.addEventListener('pointerup', stopRecording); 
                
                // F√ºgt das stop-Event zum Dokument hinzu, falls der Benutzer au√üerhalb losl√§sst (Desktop).
                // ACHTUNG: Wir nutzen hier KEIN pointerup, da wir setPointerCapture verwenden,
                // was das pointerup an den Button zur√ºcksendet, auch wenn au√üerhalb losgelassen wird.
                // Das document-level stopRecording (wie in der vorherigen Version) ist hier nicht mehr n√∂tig.

            } catch (err) {
                console.error("Fehler beim Zugriff auf das Mikrofon: ", err);
                input.value = "‚ö†Ô∏è Fehler: Mikrofonberechtigung verweigert oder Ger√§t nicht gefunden.";
                recordButton.disabled = true;
            }
        }
        window.onload = initRecorder;


    </script>

    <style>
        @keyframes bottomSheetPop {
            0%   { transform: translateY(100%) scale(0.95); }
            60%  { transform: translateY(-4px) scale(1.02); }
            100% { transform: translateY(0) scale(1); }
        }
        .bottom-sheet-pop {
            animation: bottomSheetPop 300ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        .todo-card {
            user-select: none;
        }

    </style>
</body>
</html>