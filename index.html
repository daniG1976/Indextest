<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="To Dos">  
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#fe7f2d"> <link href="https://fonts.googleapis.com/css2?family=Gloria+Hallelujah&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" href="/icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Gloria+Hallelujah&display=swap" rel="stylesheet">
    <title>To Do</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #233d4d !important;
        }

        .font-gloria {
            font-family: 'Gloria Hallelujah';
        }

        #main-title {
            /* Verhindert das Ruckeln der Schrift beim Skalieren */
            will-change: font-size, padding;
        }

        .text-xxs {
            /* Setzt die Schriftgr√∂√üe auf 0.625rem (ca. 10px), was kleiner als text-xs (12px) ist */
            font-size: 0.625rem; 
            line-height: 0.75rem; /* Optional: Stellt eine passende Zeilenh√∂he ein */
        }
        .orange-semi-circle {
            background: linear-gradient(
                to bottom,        /* Startet oben und verl√§uft nach unten */
                #ff9d47,          /* Helleres Orange (oben) */
                #fe7f2d,     /* Dein Original-Orange (#fe7f2d) startet bei 60% */
                #99440b           /* Dunkleres Orange (unten) */
            );
            
            /* NEU: Gr√∂√üere H√∂he und relative Breite, um mehr Pr√§senz zu haben */
            height: 100vh;  /* Fast die gesamte Viewport-H√∂he */
            width: 20vw;  /* Die Breite basiert nur auf 30% der Viewport-Breite */
            
            /* Radius muss gleich der Breite sein (30vw) */
            border-top-left-radius: 30vw;
            border-bottom-left-radius: 30vw; 
            
            /* Positionierung */
            position: fixed; 
            right: 0;
            top: 50%; /* Vertikal zentrieren */
            transform: translateY(-50%); 
            z-index: 5; /* Im Hintergrund */
            opacity: 0.80; 
            pointer-events: none;
        }

        .no-scroll {
            overflow: hidden; /* Verhindert das Scrollen von Inhalten, die √ºber den Viewport hinausragen */
            touch-action: none; /* WICHTIG: Deaktiviert alle standardm√§√üigen Touch-Gesten (wie vertikales Scrollen) */
        }

        .touch-action-none {
            /* WICHTIG: √úberschreibt Standard-Gesten (long press, double tap) 
            und erzwingt das Feuern von Pointer Events */
            touch-action: none !important;
        }

        .touch-action-pan-y {
            touch-action: pan-y !important;
        }

        .modal-sheet * {
            /* Deaktiviert die Markierung von Text innerhalb des Modal sheets */
            -webkit-user-select: none;  /* F√ºr Safari/Chrome */
            -moz-user-select: none;     /* F√ºr Firefox */
            -ms-user-select: none;      /* F√ºr IE/Edge */
            user-select: none;
        }

        .scrolled-header {
            /* üî• KORREKTUR: Hintergrundfarbe auf 1.0 (blickdicht) setzen, um Karten VOLLST√ÑNDIG zu verdecken */
            background-color: rgb(35, 61, 77); /* Volle Opazit√§t! */
            
            /* Blur und Webkit-Blur bleiben erhalten */
            backdrop-filter: blur(20px); 
            -webkit-backdrop-filter: blur(20px); 
}

    </style>
</head>
<body class="bg-[#233d4d] text-white min-h-screen flex flex-col items-center">
    <div class="orange-semi-circle"></div> 
    <header id="sticky-header" 
        class="fixed top-0 left-0 right-0 z-40 bg-[#233d4d] transition-all duration-300"
        style="padding-top: env(safe-area-inset-top, 0px);">
        
        <div class="max-w-lg mx-auto px-4 transition-all duration-300" id="header-inner">
            <h1 id="main-title" 
                class="font-gloria text-5xl font-extrabold text-[#fe7f2d] text-center py-6 transition-all duration-300">
                üöÄ Meine To Dos
            </h1>
        </div>
        <div id="header-border" class="w-full h-[1px] bg-white/10 opacity-0 transition-opacity duration-300"></div>
    </header>

    <div id="header-placeholder" class="w-full h-[160px]"></div>

    <main class="w-full max-w-lg mx-auto p-4 relative z-10">
        <div id="todo-list" class="space-y-4"></div>
    </main>

     <!-- FLOATING ACTION BUTTON (FAB) -->
    <button id="fab-button" 
            class="fixed bottom-6 
                   right-1/2 transform translate-x-1/2 
                   w-14 h-14 
                   rounded-full 
                   bg-[#fe7f2d] text-[#233d4d]
                   shadow-xl 
                   flex items-center justify-center text-3xl font-bold 
                   transition-all duration-300 
                   hover:scale-110 active:scale-95 
                   z-50">
        <!-- Lucide Plus Icon, h√§ufig in FABs verwendet -->
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M5 12h14"/><path d="M12 5v14"/>
        </svg>
    </button>
    <!-- ENDE FAB -->

    <!-- üî• NEUES BOTTOM SHEET -->
    <div id="bottom-sheet" 
        class="fixed inset-0 z-[100] hidden">

        <!-- Sheet-Container -->
        <div id="bottom-sheet-container"
            class="absolute bottom-0 left-0 right-0 
                    bg-[#fe7f2d]/30       /* Orange, 30% Opacity */
                    backdrop-blur-xl       /* Starker Blur f√ºr Glassmorphism */
                    rounded-t-3xl shadow-2xl
                    p-6 
                    transform translate-y-full 
                    transition-transform duration-300">
            <!-- Close Button oben rechts -->
            <button id="close-bottom-sheet-button"
                    class="absolute top-4 right-4 text-[#233d4d] hover:text-gray-800">
                <!-- kleines X-Icon im iOS/Material-Stil -->
                <svg xmlns="http://www.w3.org/2000/svg" 
                    width="24" height="24" viewBox="0 0 24 24" 
                    fill="none" stroke="currentColor" 
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>


             <!-- Modal Header -->
            <h3 class="text-3xl font-bold text-[#fe7f2d] mb-4">
                <span class="font-gloria text-3xl mr-3">üìù Neues To Do</span>   
            </h3>
            <!-- Textarea -->
            <textarea id="unified-todo-input"
                    class="w-full h-12 p-3 rounded-xl bg-white/10 backdrop-blur-sm text-[#233d4d] resize-none 
                            placeholder-[#fe7f2d] font-gloria focus:outline-none focus:ring-2 focus:ring-orange-700 transition duration-150 shadow-inner mb-4"
                    placeholder="..."></textarea>


            <!-- Button-Leiste: Record & Photo & Save -->
            <div class="flex justify-center space-x-16 pt-2">
                <!-- Mikrofon (Press-and-Hold) -->
                <button id="record-button"
                        class="w-14 h-14 rounded-full bg-[#233d4d] hover:bg-[#3b5971] text-[#fe7f2d] shadow-xl transition duration-150 disabled:opacity-50 flex items-center justify-center text-2xl active:recording-pulse touch-action-none"
                        title="Halten Sie die Maustaste gedr√ºckt, um aufzunehmen">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 z-10">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" x2="12" y1="19" y2="22"/>
                    </svg>
                </button>

                <button id="photo-button"
                        class="w-14 h-14 rounded-full bg-[#233d4d] hover:bg-[#3b5971] text-[#fe7f2d] shadow-xl transition duration-150 flex items-center justify-center text-2xl"
                        title="Bilder hinzuf√ºgen">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                        <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
                        <circle cx="12" cy="13" r="3"/>
                    </svg>
                </button>

                <!-- Add / Save Button (Primary Action - Plus Icon) -->
                <button id="save-unified-button"
                        class="w-14 h-14 rounded-full bg-[#233d4d] hover:bg-[#3b5971] text-[#fe7f2d] shadow-xl transition duration-150 disabled:opacity-50 flex items-center justify-center text-3xl font-bold"
                        title="Aufgabe speichern">
                    +
                </button>
            </div>

        </div>
    </div>

    <script>
        // *** Frontend-Logik: Aufnahme, Base64-Kodierung & Senden an Python-Backend ***
        
        // Konstanten f√ºr UI-Elemente
        const API_BASE_URL = "https://indextest-ogpo.onrender.com";
        const statusText = document.getElementById('status-text');
        const recordButton = document.getElementById('record-button');
        const resultText = document.getElementById('result-text');
        const base64Size = document.getElementById('base64-size');
        const statusContainer = document.getElementById('status-container');
        const fabButton = document.getElementById('fab-button'); 
        const bottomSheet = document.getElementById("bottom-sheet");
        const bottomSheetContainer = document.getElementById("bottom-sheet-container");
        const closeBottomSheetButton = document.getElementById("close-bottom-sheet-button");
        const input = document.getElementById("unified-todo-input");
        const saveButton = document.getElementById("save-unified-button");
        const todoList = document.getElementById("todo-list");
        const stickyHeader = document.getElementById('sticky-header');
        const title = document.getElementById('main-title');
        const border = document.getElementById('header-border');
        const headerBackground = document.getElementById('full-width-bg');
        const scrollThreshold = 40;

        let mediaRecorder;
        let audioChunks = [];
        let stream;
        let isRecording = false; 

        const preferredMimeType = MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : 'audio/webm';

        // Blockiert das Kontextmen√º/Long-Press-Men√º auf dem Button
        recordButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        function openBottomSheet() {
            bottomSheet.classList.remove("hidden");

            // erst runterholen
            bottomSheetContainer.classList.remove("translate-y-full");

            // Pop-Animation sauber resetten
            bottomSheetContainer.classList.remove("bottom-sheet-pop");
            void bottomSheetContainer.offsetWidth; 
            bottomSheetContainer.classList.add("bottom-sheet-pop");
        }

        fabButton.addEventListener("click", openBottomSheet);

        
        function closeBottomSheet() {
            bottomSheetContainer.classList.remove("bottom-sheet-pop");
            bottomSheetContainer.classList.add("translate-y-full");

            setTimeout(() => {
                bottomSheet.classList.add("hidden");
            }, 300);
        }

        closeBottomSheetButton.addEventListener("click", closeBottomSheet);

        saveButton.addEventListener("click", () => {
            const text = input.value.trim();
            if (!text) return;

            createTodoCard(text);
            input.value = ""; // leeren

            closeBottomSheet(); // ‚Üê das ist jetzt alles
        });

        function enableSwipe(card, bg, wrapper, id) {
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            const threshold = 150; 
            const maxShift = 300; 

            // Referenzen auf die Icons holen
            const completeIcon = bg.querySelector(`#icon-complete-${id}`);
            const deleteIcon = bg.querySelector(`#icon-delete-${id}`);
            
            function start(positionX) {
                document.body.classList.add('no-scroll'); 
                startX = positionX;
                isDragging = true;
                card.style.transition = "none";
            }

            function move(positionX) {
                if (!isDragging) return;
                currentX = positionX - startX;
                
                if (Math.abs(currentX) < 10) return;

                card.style.transform = `translateX(${currentX}px)`;

                const intensity = Math.min(Math.abs(currentX) / maxShift, 1);
                
                // 1. Hintergrund-Opazit√§t einstellen
                bg.style.opacity = intensity * 0.9;
                
                // Alte Farbkassen entfernen
                bg.classList.remove('bg-red-600', 'bg-green-600'); 
                
                // 2. Richtungserkennung und Anpassung von Farbe/Icon
                if (currentX > 0) { // SWIPE RECHTS (Erledigen)
                    bg.classList.add('bg-green-600');
                    
                    // Haken zeigen, M√ºlleimer verstecken
                    completeIcon.style.opacity = intensity * 1.5 > 1 ? 1 : intensity * 1.5;
                    deleteIcon.style.opacity = '0';

                } else if (currentX < 0) { // SWIPE LINKS (L√∂schen)
                    bg.classList.add('bg-red-600');

                    // M√ºlleimer zeigen, Haken verstecken
                    completeIcon.style.opacity = '0';
                    deleteIcon.style.opacity = intensity * 1.5 > 1 ? 1 : intensity * 1.5;
                }

                // Textfarbe ver√§ndern (optional)
                if (intensity > 0.5) {
                    card.classList.remove('text-[#fe7f2d]');
                    card.classList.add('text-white');
                } else {
                    card.classList.remove('text-white');
                    card.classList.add('text-[#fe7f2d]');
                }
            }

            function end() {
                if (!isDragging) return;
                isDragging = false;
                
                document.body.classList.remove('no-scroll');
                card.style.transition = "0.2s";

                if (Math.abs(currentX) > threshold) {
                    // Aktion best√§tigen
                    card.style.transform = `translateX(${currentX > 0 ? 500 : -500}px)`;
                    
                    // Aktionstyp bestimmen: 'complete' (rechts) oder 'delete' (links)
                    const actionType = currentX > 0 ? 'complete' : 'delete';
                    
                    // Aufruf des zentralen Handlers
                    setTimeout(() => handleSwipeAction(id, actionType), 200);

                } else {
                    // Zur√ºcksetzen
                    card.style.transform = "translateX(0)";
                    bg.style.opacity = '0';
                    bg.classList.remove('bg-red-600', 'bg-green-600');
                    
                    // Beide Icons verstecken
                    completeIcon.style.opacity = '0';
                    deleteIcon.style.opacity = '0';

                    card.classList.remove('text-white');
                    card.classList.add('text-[#fe7f2d]');
                }
                
                currentX = 0; 
            }

            card.addEventListener("touchstart", (e) => start(e.touches[0].clientX));
            card.addEventListener("touchmove", (e) => move(e.touches[0].clientX));
            card.addEventListener("touchend", end);

            card.addEventListener("mousedown", (e) => start(e.clientX));
            window.addEventListener("mousemove", (e) => move(e.clientX));
            window.addEventListener("mouseup", end);
        }

        window.addEventListener('scroll', () => {
            const header = document.getElementById('sticky-header');
            const title = document.getElementById('main-title');
            const border = document.getElementById('header-border');
            
            if (window.scrollY > 20) {
                // Zustand: Gescrollt (WhatsApp Style)
                title.classList.remove('text-5xl', 'py-6');
                title.classList.add('text-2xl', 'py-3');
                
                header.classList.add('shadow-2xl');
                border.classList.replace('opacity-0', 'opacity-100');
            } else {
                // Zustand: Ganz oben
                title.classList.remove('text-2xl', 'py-3');
                title.classList.add('text-5xl', 'py-6');
                
                header.classList.remove('shadow-2xl');
                border.classList.replace('opacity-100', 'opacity-0');
            }
        });

        function handleSwipeAction(id, actionType) {
            const wrapper = document.getElementById(`card-wrapper-${id}`); 
            const card = document.getElementById(`card-${id}`); 
            
            if (!wrapper || !card) return;

            // ZUK√úNFTIGE LOGIK HIER:
            if (actionType === 'delete') {
                console.log(`TASK ${id}: Gel√∂scht (muss noch in LocalStorage implementiert werden)`);
                // Hier: LocalStorage-Logik, um die Aufgabe dauerhaft zu entfernen
            } else if (actionType === 'complete') {
                console.log(`TASK ${id}: Erledigt (muss noch in LocalStorage implementiert werden)`);
                // Hier: LocalStorage-Logik, um den 'completed' Status auf true zu setzen
            }

            // 1. Visuelle Pop-Out-Animation starten
            // (Die horizontale Verschiebung vom Swipe ist noch aktiv!)
            card.style.transition = "all 0.15s ease-out";
            card.style.transform += ' scale(0.9)'; 
            card.style.opacity = '0';
            
            // 2. Vertikales Collapse vorbereiten und starten
            const wrapperHeight = wrapper.offsetHeight;
            
            wrapper.style.height = `${wrapperHeight}px`;
            wrapper.style.overflow = 'hidden';
            wrapper.style.transition = 'height 0.3s ease-out, margin 0.3s ease-out';
            
            setTimeout(() => {
                wrapper.style.height = '0';
                wrapper.style.marginBottom = '0'; 
            }, 150);

            // 3. DOM-Entfernung
            const totalDuration = 150 + 300; 

            setTimeout(() => {
                wrapper.remove();
                // Hier w√ºrde nach dem LocalStorage-Update die Liste neu geladen/aktualisiert werden.
            }, totalDuration);
        }

        function createTodoCard(text) {
            const id = Date.now(); 

            const wrapper = document.createElement("div");
            wrapper.id = `card-wrapper-${id}`;
            wrapper.className = "swipe-wrapper relative mb-4 bg-transparent";

            //Datum
            const now = new Date();
            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const year = now.getFullYear();
            const formattedDate = `${day}.${month}.${year}`;
            
            // Innere Karte
            const card = document.createElement("div");
            card.id = `card-${id}`; // WICHTIG: ID f√ºr die Animation
            card.className = `
                todo-card
                bg-gradient-to-r from-[#233d4d]/20 to-[#fe7f2d]/90
                backdrop-blur-xl
                text-[#fe7f2d]
                rounded-2xl p-4 shadow-lg
                transition-transform duration-300
                relative z-10
                touch-action-pan-y
            `;

            card.innerHTML = `
                <div class="flex justify-between items-center">
                    <p class="text-2xl">${text}</p>
                    <span class="drag-handle text-[#233d4d] text-2xl opacity-90 touch-action-none">‚ò∞</span>
                </div>
                <div class="w-full flex justify-between items-center">
                    <span class="text-xxs text-[#fe7f2d] font-sans tracking-wider">
                        ${formattedDate}
                    </span>
                </div>
            `;

            // ROTE/GR√úNE AKTIONEN FL√ÑCHE
            const bg = document.createElement("div");
            bg.className = `
                swipe-action-bg absolute inset-0 
                rounded-2xl 
                opacity-0 transition-opacity duration-200
                flex items-center justify-between
                px-8 /* Abstand f√ºr Icons */
                pointer-events-none                
            `;

            bg.innerHTML = `
                <svg id="icon-complete-${id}" class="w-10 h-10 text-white opacity-0 transition-opacity duration-150" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>

                <svg id="icon-delete-${id}" class="w-10 h-10 text-white opacity-0 transition-opacity duration-150" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
                </svg>
            `;

            wrapper.appendChild(bg);
            wrapper.appendChild(card);
            todoList.appendChild(wrapper);

            enableSwipe(card, bg, wrapper, id);
            enableReorder(wrapper);
        }

        // NEUE, STABILE FUNKTION
        function enableReorder(wrapper) {
            const card = wrapper.querySelector(".todo-card"); 
            const handle = card.querySelector(".drag-handle");
            const list = todoList; 

            let isDragging = false;
            let startY = 0;
            let initialWrapperY = 0; // Absolute Y-Position des Wrappers beim Start

            function pointerDown(e) {
                if (e.button === 2) return; 

                e.stopPropagation(); 
                e.preventDefault();

                document.body.classList.add('no-scroll');
                
                isDragging = true;
                
                // üî• WICHTIG: Die Y-Position des Zeigers bestimmen
                startY = e.clientY || e.touches?.[0]?.clientY; 

                // üî• L√ñSUNG F√úR PROBLEM 2 (Breite und Position fixieren)
                const rect = wrapper.getBoundingClientRect();
                
                wrapper.style.position = 'fixed'; // FIXED ist einfacher als absolute + scrollY
                wrapper.style.width = `${rect.width}px`;
                wrapper.style.left = `${rect.left}px`; ¬†
                
                // Y-Position relativ zum Viewport setzen:
                initialWrapperY = rect.top; // Wir verwenden 'fixed', daher reicht rect.top
                wrapper.style.top = `${initialWrapperY}px`; 

                wrapper.style.zIndex = '1000';
                card.style.transition = "none";
                card.classList.add("opacity-50", "scale-95", "shadow-2xl");

                document.addEventListener("pointermove", pointerMove);
                document.addEventListener("pointerup", pointerUp);
            }

            function pointerMove(e) {
                if (!isDragging) return;

                const y = e.clientY || e.touches?.[0]?.clientY;
                const delta = y - startY;
                
                // 1. Position des gezogenen Elements im Viewport aktualisieren
                wrapper.style.top = `${initialWrapperY + delta}px`;

                const cards = [...list.children];
                
                // 2. Finde das N√ÑCHSTE ZIELELEMENT
                // Wir suchen das erste Element, dessen Mittelpunkt der Zeiger gerade √ºberschreitet.
                // Davor muss unsere gezogene Karte eingef√ºgt werden.
                const targetElement = cards.find(otherWrapper => {
                    // Das gezogene Element selbst ignorieren
                    if (otherWrapper === wrapper) return false; 
                    
                    const rect = otherWrapper.getBoundingClientRect();
                    const middle = rect.top + rect.height / 2;
                    
                    // TargetElement ist das erste, dessen MITTELPUNKT sich NOCH unter der Pointer-Position (y) befindet, 
                    // ABER der Pointer ist gerade √úBER seiner Mitte.
                    return y < middle;
                });

                // 3. Tausch basierend auf dem gefundenen Ziel durchf√ºhren (nur EINMAL)
                if (targetElement) {
                    // Wenn ein Ziel gefunden wurde (z.B. Card 2), ist der Pointer √ºber dessen Mitte.
                    // F√úGE VOR Card 2 ein.
                    // Dies funktioniert auch f√ºr die 1. Karte (wenn y √ºber ihrer Mitte ist).
                    if (targetElement.previousElementSibling !== wrapper) {
                        list.insertBefore(wrapper, targetElement);
                    }
                } else {
                    // Wenn kein Ziel gefunden wurde (d.h. der Pointer ist UNTER allen Elementen):
                    const lastCard = list.lastElementChild;
                    
                    if (lastCard && lastCard !== wrapper) {
                        const rect = lastCard.getBoundingClientRect();
                        const middle = rect.top + rect.height / 2;

                        // Pr√ºfe, ob der Pointer wirklich unter der letzten Karte liegt
                        if (y > middle) {
                            // F√úGE HINTER dem letzten Element ein.
                            if (lastCard.nextElementSibling !== wrapper) {
                                list.insertBefore(wrapper, lastCard.nextSibling);
                            }
                        }
                    }
                }
            }

            function pointerUp() {
                if (!isDragging) return;

                isDragging = false;

                document.body.classList.remove('no-scroll');

                // üî• RESET DER POSITIONIERUNG
                card.style.transition = "0.2s";
                
                // Entfernt die 'fixed' Positionierung
                wrapper.style.removeProperty('position');
                wrapper.style.removeProperty('top');
                wrapper.style.removeProperty('left');
                wrapper.style.removeProperty('width');
                wrapper.style.removeProperty('z-index'); 
                
                card.classList.remove("opacity-50", "scale-95", "shadow-2xl");

                document.removeEventListener("pointermove", pointerMove);
                document.removeEventListener("pointerup", pointerUp);
            }

            // ACHTUNG: pointerdown/move/up verwenden, um Touch- und Maus-Events zu vereinen
            handle.addEventListener("pointerdown", pointerDown);
        }

        async function transcribeAudio(base64Audio, mimeType) {
            // Besseres Feedback, falls der Server erst hochfahren muss
            input.value = "Verarbeitung l√§uft... (Das Backend wacht evtl. gerade auf ‚òï)";

            try {
                // Setze einen l√§ngeren Timeout f√ºr den ersten Request nach dem Sleep
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 Sek Zeit geben

                const response = await fetch(API_BASE_URL + '/transcribe', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ audio_base64: base64Audio, mime_type: mimeType }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const data = await response.json();

                if (response.ok) {
                    input.value = data.transcript; 
                    input.focus(); 
                } else {
                    input.value = `[FEHLER] ${data.error || "Serverfehler"}`; 
                }
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    input.value = "[TIMEOUT] Das Backend hat zu lange zum Aufwachen gebraucht. Bitte gleich noch mal versuchen!";
                } else {
                    input.value = `[NETZWERKFEHLER] ${error.message}`;
                }
            }
        }

        function startRecording(e) {
            // 1. Pr√ºfe, ob wir schon aufnehmen oder ob es nicht der Record Button ist.
            if (isRecording) return;
            
            // 2. Wichtig: Verhindert, dass der Browser ein unn√∂tiges Click-Event ausl√∂st,
            //    aber wir m√ºssen den Pointer Capture setzen.
            e.preventDefault(); 
            
            // 3. Wenn es ein Pointer-Event ist, Capture setzen.
            if (e.pointerId !== undefined) {
                // Stellt sicher, dass das pointerup-Event auch au√üerhalb des Buttons gefeuert wird.
                e.target.setPointerCapture(e.pointerId); 
            }
            
            if (!stream) {
                input.value = "[FEHLER] Mikrofon nicht bereit. Erlaubnis verweigert?";
                return;
            }
            
            isRecording = true;
            recordButton.classList.add('recording-pulse');
            input.value = "üî• Aufnahme l√§uft... ";

            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: preferredMimeType });
            } catch (error) {
                input.value = `[FEHLER] MediaRecorder konnte nicht initialisiert werden: ${error.message}`;
                isRecording = false;
                recordButton.classList.remove('recording-pulse');
                return;
            }

            audioChunks = [];
            
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                if (audioChunks.length === 0) {
                    input.value = "[HINWEIS] Aufnahme zu kurz oder keine Daten erfasst.";
                    return;
                }

                const mimeType = mediaRecorder.mimeType;
                const audioBlob = new Blob(audioChunks, { type: mimeType });
                const reader = new FileReader();
                
                reader.onloadend = () => {
                    const base64Audio = reader.result.split(',')[1];
                    transcribeAudio(base64Audio, mimeType);
                };
                reader.readAsDataURL(audioBlob);
            };

            mediaRecorder.start();
            console.log("Aufnahme gestartet...");
        }

        function stopRecording(e) {
            if (!isRecording) return;
            
            isRecording = false; 
            recordButton.classList.remove('recording-pulse');

            // Wenn Pointer Capture gesetzt wurde, muss es freigegeben werden.
            if (e.pointerId !== undefined) {
                e.target.releasePointerCapture(e.pointerId);
            }
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                console.log("Aufnahme gestoppt. Starte Transkription...");
            }
        }

        async function wakeUpBackend() {
            console.log("Wecke Backend auf...");
            try {
                // Wir senden einen einfachen GET-Request an eine (evtl. neue) Health-Route 
                // oder einfach an dein Haupt-URL. 
                // Auch wenn es ein 404 gibt, wacht Render trotzdem auf!
                fetch(API_BASE_URL + '/health').catch(() => {}); 
                
                // Alternativ: Ein leerer POST an /transcribe (w√ºrde einen Fehler werfen, weckt aber auch)
            } catch (e) {
                // Fehler ignorieren, es geht nur um den Ping
            }
        }

        async function initRecorder() {
            wakeUpBackend();
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log(`Mikrofon bereit. Format: ${preferredMimeType}`);
                recordButton.disabled = false;
                
                // üî• WICHTIG: pointerdown/pointerup verwenden, aber nur auf dem Button lauschen
                recordButton.addEventListener('pointerdown', startRecording); 
                recordButton.addEventListener('pointerup', stopRecording); 
                
                // F√ºgt das stop-Event zum Dokument hinzu, falls der Benutzer au√üerhalb losl√§sst (Desktop).
                // ACHTUNG: Wir nutzen hier KEIN pointerup, da wir setPointerCapture verwenden,
                // was das pointerup an den Button zur√ºcksendet, auch wenn au√üerhalb losgelassen wird.
                // Das document-level stopRecording (wie in der vorherigen Version) ist hier nicht mehr n√∂tig.

            } catch (err) {
                console.error("Fehler beim Zugriff auf das Mikrofon: ", err);
                input.value = "‚ö†Ô∏è Fehler: Mikrofonberechtigung verweigert oder Ger√§t nicht gefunden.";
                recordButton.disabled = true;
            }
        }
        window.onload = initRecorder;

        // üî• PWA Service Worker Registrierung
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                // Wir registrieren den Worker mit dem Pfad, wo die Datei liegt
                navigator.serviceWorker.register('./service-worker.js', { scope: './' })
                    .then(function(registration) {
                        console.log('ServiceWorker registriert mit Scope: ', registration.scope);
                    }, function(err) {
                        console.log('ServiceWorker Registrierung fehlgeschlagen: ', err);
                    });
            });
        }


    </script>

    <style>
        @keyframes bottomSheetPop {
            0%   { transform: translateY(100%) scale(0.95); }
            60%  { transform: translateY(-4px) scale(1.02); }
            100% { transform: translateY(0) scale(1); }
        }
        .bottom-sheet-pop {
            animation: bottomSheetPop 300ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        .todo-card {
            user-select: none;
        }

    </style>
</body>
</html>